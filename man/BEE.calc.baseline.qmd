---
title: "BEE.calc.baseline"
author: "Victoria"
format: html
editor: visual
editor_options: 
  chunk_output_type: console
---

*BEE.calc.baseline* : Creates a baseline from a SpatRaster by compiling cell data according to the chosen threshold

Only two threshold can be set :

-   "*qt*" : calculate the value of the 90th percentile for each cell at the time resolution of the dataset. For instance, it calculate the value of the threshold for each day of a theoretical year if the data has a daily resolution or for each month if data has a monthly resolution. To simplify analysis, the 29th of February is deleted if present.
-   "*mean*" : calculate the mean value for each cell at the time resolution of the data set .

BEE.calc.baseline is not designed to work on 4D data (time + spatial 3D).

# rast_name = ds ; start_date=NULL; end_date = "1987-12-31" ; threshold = "qt"; quantile_value = 0.9 ; time_window = 5; smooth_window=10

```{r}
#' Calculate baseline value for each pixel.
#' @BEE.calc.baseline
#' @param rast_name the SpatRaster containing the values to use to calculate baseline. It must have a date per layer.
#' @param start_date the date to use as the first day of your reference period. It must be in YYYY-MM-DD format.
#' @param end_date the date to use as the last day of your reference period. It must be in YYYY-MM-DD format.
#' @param threshold tells whether you want to use a percentile or the mean of the observed value as threshold. Accepted arguments are "qt" to specify you want to compute a percentile of the observed values in the reference timeframe. Or "mean" if you wnat to use the mean of observed values in the timeframe provided as threshold. 
#' @param quantile_value indicates the percentile value you want to use. It must be between 0 and 1.
#' @param time_window number of days you want to account on each size of day 'd' to calculate the threshold value on 'd' day. For instance time_window = 5 means that the value from day d - 5 days, day d and until day d + of all years between start_date and end_date will be use to calculate the threshold at day d of the year.
#' @param smooth_window half the number of days minus one that you want to use to smooth you baseline in time. For instance, smooth_window = 10 minutes the final value at day 'd' will be the mean of the baseline values calculate for day d - 10 to d + 10 (elven values). 
#'
#' @returns a SpatRaster with on day of the year per layer (366 layers), having the same extent, pixel resolution and crs than the provided SpatRaster.
#' @export
#'

BEE.calc.baseline <- function(rast_name, start_date=NULL, end_date=NULL, threshold, quantile_value=NULL, time_window=5, smooth_window=10){
  
  # Subset the dataset to the chosen strat_date and end-date if necessary
  if (is.null(start_date) | !is.null(end_date)){
    if ( is.null(start_date) ){
      start_date <- names(rast_name)[1]
      warning("You have provided an 'end_date' but no 'start_date', first date of the dataset (",start_date,") have been used as first day of the baseline."  )
    }
    if ( is.null(end_date) ){
      end_date <- names(rast_name)[nlyr(rast_name)]
      warning("You have provided a 'start_date' but no 'end_date', last date of the dataset (", end_date,") have been used as last day of the baseline."  )
    }
  }
  # Cut rast_name to only keep the part between start_date and end_date
  dates <- as.Date(time(rast_name))
  to_keep <- which(dates >= as.Date(start_date) & dates <= as.Date(end_date))
  rast_name <- rast_name[[to_keep]]
  # Function to detect leap years
  is_leap_year <- function(years) {
    return((years %% 4 == 0 & years %% 100 != 0) | (years %% 400 == 0))
  }
  dates <- as.Date(time(rast_name))  # Dates
  years <- as.integer(format(dates, "%Y")) # Years
  # Build a dataframe with the layer number, the doy and the corrected doy (366, 60 don't exist in non leap year)
  df <- data.frame( date = dates,
                    N_layer = seq(1,nlyr(rast_name),1),
                    leap_year = is_leap_year((years)),
                    doy = as.integer(format(dates, "%j"))) #day of the year
  df$doy2 <- ifelse(df$doy >= 60 & !df$leap_year, df$doy+1, df$doy)
  # For each day of the year from 0 to 366, get a list of the layers to use to calculate baseline
  doy_indices <- vector("list", 366)
  for (j in 1:366) {
    days_in_window <- ((j - time_window):(j + time_window)) %% 366 ## %% 366 is a 'modulo' which mean that when a number reach 366 it is converted to 0 and the series that over from 0, 1, 2...
    days_in_window[days_in_window == 0] <- 366 # to avoid 0
    doy_indices[[j]]<- df$N_layer[which(df$doy2 %in% days_in_window)]
  }
  # Calculate baseline according the chosen methodology
  if (threshold == "qt"){
    # function to calculate percentile on a specific time_window
    q_rolling <- function(values, na.rm = TRUE) {
      terra::quantile(values, probs = quantile_value, na.rm = na.rm)
    }
  baseline_list <- lapply(1:366, function(i) {
      terra::app(rast_name[[doy_indices[[i]]]], fun = q_rolling)
    })
  baseline <- rast(baseline_list) #convert to Spatraster
  } else if (threshold == "mean"){        # if the baseline chosen is a mean value then enter loop bellow
    baseline_list <- lapply(1:366, function(i) {
      terra::app(rast_name[[doy_indices[[i]]]], fun = mean)
    })
  baseline <- rast(baseline_list) #convert to Spatraster
  }   
  # Smooth the value with an 11 days moving average
  smooth_indices <- vector("list", 366)
  for (s in 1:366) {
    days_in_window <- ((s - smooth_window):(s + smooth_window)) %% 366
    days_in_window[days_in_window == 0] <- 366  
    smooth_indices[[s]] <- days_in_window
  }
  baseline <- lapply(1:366, function(i) {
    terra::app(baseline[[smooth_indices[[i]]]], fun = mean, na.rm = TRUE)
    })
  baseline <- rast(baseline)
  return(baseline)
}

```
