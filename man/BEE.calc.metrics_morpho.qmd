---
title: "BEE.calc.metrics_morpho"
author: "Victoria and Nicolas C"
format: html
editor: visual
editor_options: 
  chunk_output_type: console
---

@description This function give the morphological metrics for an extreme event Corrected_raster is the SpatRaster you want to analyze (it needs to be be binarise with the mhw function)

@param Corrected_raster the SpatRaster you want to analyse @param Output is the way you want your data to be its either a SpatRaster or a Data frame @param Coord id a two columns matrix or data frame with x and y gps coordinates @param start_date and end_date allows to perform the analysis on a specific time_frame, this allows to save computation time.

@note Your SpatRaster need to be binarised with the mhw function before you put it in this function, you also may want to apply

BEE.calc.metrics_morpho is not designed to work on 4D data (time + spatial 3D).
#start_date \<- "2022-01-01" ; end_date \<- "2023-12-31"

```{r}
BEE.calc.metrics_morpho <- function(Corrected_rasters, start_date = NULL, end_date = NULL, patch_per_pix = FALSE) {
  # Retrive the dataframe if required
  if (!is.null(start_date) | !is.null(end_date)){
    ## Check that date format matches
    format_start_date <- guess_formats(start_date, orders = c("dmy", "ymd", "mdy"))
    format_end_date <- guess_formats(end_date, orders = c("dmy", "ymd", "mdy"))
    format_layers_names <- guess_formats(names(Corrected_rasters[[1]]), orders = c("dmy", "ymd", "mdy"))
    same_format <- all(format_start_date %in% format_layers_names)
    same_format <- c(same_format, all(format_end_date %in% format_layers_names))
    if(any(same_format==FALSE)){
      warning("The format of start_date or end_date does not match the format of the dates in Corrected_raster. Please run names(Corrected_raster[[1]]) to check the required format.")
      stop()
    }
    else{
      ## Retrive
      start_date <- ifelse(is.null(start_date), names(Corrected_rasters[[1]]), start_date)
      end_date <- ifelse(is.null(end_date), names(Corrected_rasters[[nlyr(Corrected_rasters)]]), end_date)
      rasters <- Corrected_rasters[[which(names(Corrected_rasters) >= start_date & names(Corrected_rasters) <= end_date)]]
    }
  }
  if (is.null(start_date) & is.null(end_date)){
    ## Adjust variable name to match the rest of the function
  rasters <- Corrected_rasters 
  }

  patch_list <- lapply(rasters, FUN = function(rasters){
    patch <- patches(rasters, directions = 8, zeroAsNA = T, allowGaps = T)
    return(patch)
  })
    
  # dist <- lapply(patch_list, FUN = function(x){ # x <- patch_list[[120]] ; calculate distance to edge of the patch (outside of an extreme event)
  #   vals <- values(x)
  #   vals <- vals[!is.nan(vals)]
  #   if (any(vals== 0)) {
  #       dist <- terra::distance(x, target = 1, exclude = NaN, unit = "km")
  #       } else {
  #       values(x)<- NaN
  #       dist <- x
  #       }
  #   return(dist)
  # })
    
    
  dist_list <- lapply(patch_list, function(x) { # x <- patch_list[[1]]
    # Create a df with on row per pixel
    vals <- values(x)
    cell_size <- values(cellSize(x))[,1]
    boundary <- terra::boundaries(x, directions = 8)
    coordonates <- xyFromCell(x, 1:ncell(x))
    d <- time(x)

    data <- data.table(
      x = coordonates[,1],
      y = coordonates[,2],
      values = vals,
      cell_size = cell_size,
      boundary = values(terra::boundaries(x, directions = 8))
    ) %>% rename(patch_id = values.patches , 
                  boundary = boundary.patches)
      
    data[, length_boundary := sum(boundary), by = patch_id]
    data[, patch_area := sum(cell_size), by = patch_id]
    data[, core_area := sum(cell_size * (boundary == 0)), by = patch_id]
    data[, area_index := core_area / patch_area]
    data[, n_pixel := .N, by = patch_id]  
    data[, pixel_tot := sum(unique(n_pixel))]
    data[, cover_percent := n_pixel / pixel_tot]
    data[, core_pixel := n_pixel - length_boundary]
        
    polygon <- as.polygons(x, aggregate = T, round = F)
    perim <- data.table(perimeter = terra::perim(polygon))

    id <- data[!is.nan(patch_id), .(patch_id = unique(patch_id))]
        
    perim[, patch_id := id]
        
    data <- merge(data, perim, by = "patch_id", all.x = TRUE)
        
    data <- data %>%
      select(-cell_size,-pixel_tot)
        
    if (length(polygon) == 0) {
        data[,perim_area_ratio := length_boundary / n_pixel, by = patch_id]
        data[,shape_index := (0.25 * length_boundary / (n_pixel) ^ 0.5), by = patch_id]
        data[,fract_corel_dim := (
          2 * log(0.25 * length_boundary, base = exp(1)) / log(n_pixel, base = exp(1))
          ), by = patch_id]

      } else {
        centro <- terra::centroids(polygon, TRUE)
        centro <- terra::extract(x, centro, xy = TRUE)
        centro <- centro %>%
          dplyr::select(patches, x, y) %>%
          rename(
            centroid_x = x,
            centroid_y = y,
            patch_id = patches)
        data <- merge(data, centro, by = "patch_id", all.x = TRUE)
          
        data[,perim_area_ratio := length_boundary / n_pixel, by = patch_id]
        data[,shape_index := (0.25 * length_boundary / (n_pixel) ^ 0.5), by = patch_id]
        data[,fract_corel_dim := (
          2 * log(0.25 * length_boundary, base = exp(1)) / log(n_pixel, base = exp(1))
          ), by = patch_id]
        data[, date := d] 
        }
      return(data)
    }) # one dt per pixel
  
  names(dist_list)<- time(rasters) 
  
  # Summarise by patch
  data_summarised <- lapply(dist_list, function(x){ # x <- dist_list[[1]]
    x <- unique(x, by = "patch_id")
    x[,':='(x=NULL,y=NULL)]
      return(x)
  })
  
  # Add a list of patch_ID per pixel (/!\ there are several patch_ID per EE because we cannot do spatio-temporal analysis here)
  if (patch_per_pix == TRUE) {
  pixels_nb <- seq(1,nrow(dist_list[[1]]))
  dist_tab <- bind_rows(dist_list)
  setDT(dist_tab)
  dist_tab[,pixel_ID := rep(pixels_nb, length(dist_list))]
  dist_tab[, date_patch := ifelse(is.nan(patch_id), NaN, paste0(date, '_', as.character(patch_id)))]
  matching <- dist_tab[, .(patch_ID = list(date_patch)), by = pixel_ID]
  patch_list <- rast(patch_list)
  names(patch_list) <- time(rasters)
  output <- list(data_summarised, patch_list, matching)
  return(output)
  }
  patch_list <- rast(patch_list)
  names(patch_list) <- time(rasters)
  output <- list(data_summarised, patch_list)  
  return(output)
}

```
