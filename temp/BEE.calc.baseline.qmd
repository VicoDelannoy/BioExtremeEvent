---
title: "BEE.calc.baseline"
author: "Victoria"
format: html
editor: visual
editor_options: 
  chunk_output_type: console
---

*BEE.calc.baseline* : Creates a baseline from a SpatRaster by compiling cell data according to the chosen threshold

Only two threshold can be set :

-   "*qt*" : calculate the value of the 90th percentile for each cell at the time resolution of the dataset. For instance, it calculate the value of the threshold for each day of a theoretical year if the data has a daily resolution or for each month if data has a monthly resolution. To simplify analysis, the 29th of February is deleted if present.
-   "*mean*" : calculate the mean value for each cell at the time resolution of the data set .

BEE.calc.baseline is not designed to work on 4D data (time + spatial 3D).

# YourSpatraster = ds ; start_date=NULL; end_date = "1987-12-31" ; threshold = "qt"; quantile_value = 0.9 ; time_window = 5; smooth_window=10

```{r}
#' Calculate baseline value for each pixel.
#' @BEE.calc.baseline
#' @param YourSpatraster the SpatRaster that contains the values to be used for calculating the baseline (your time serie of reference). It must have a date for each layer and no duplicated date.
#' @param start_date the date to use as the first day of your reference period. It must be in the format YYYY-MM-DD.
#' @param end_date the date to use as the last day of your reference period. It must be in the format YYYY-MM-DD.
#' @param threshold tells whether you want to use a percentile or the mean of the observed value as threshold. Accepted arguments are "qt" to specify you want to compute a percentile of the observed values in the reference timeframe, or "mean" if you want to use the mean of the observed values in the timeframe provided as threshold. 
#' @param quantile_value indicates the desired percentile value. This must be between 0 and 1.
#' @param time_window number of days on either side of day 'd' that are used to calculate the threshold value on 'd' day. For instance if time_window = 5, the value will be calculated using data from five days before day d, day d itself, and five days after day d, from all years between start_date and end_date. (The example assume that you have one layer per day.)
#' @param smooth_window number of days on either side of day 'd' that are used to compute a mean value assigned to the 'd' day. For example, if smooth_window is set to 10 days, the final value on day d will be the mean of the baseline values calculated for days d - 10 to d + 10 (eleven values).
#'
#' @returns a SpatRaster with on day of the year per layer (366 layers), having the same extent, pixel resolution and crs than the provided SpatRaster.
#' @export
#'

BEE.calc.baseline <- function(YourSpatraster, start_date=NULL, end_date=NULL, threshold, quantile_value=NULL, time_window=5, smooth_window=10){
  
  # Subset the dataset to the chosen strat_date and end-date if necessary
  if (is.null(start_date) | !is.null(end_date)){
    if ( is.null(start_date) ){
      start_date <- terra::names(YourSpatraster)[1]
      warning("You have provided an 'end_date' but no 'start_date', first date of the dataset (",start_date,") have been used as first day of the baseline."  )
    }
    if ( is.null(end_date) ){
      end_date <- terra::names(YourSpatraster)[terra::nlyr(YourSpatraster)]
      warning("You have provided a 'start_date' but no 'end_date', last date of the dataset (", end_date,") have been used as last day of the baseline."  )
    }
  }
  # Cut YourSpatraster to only keep the part between start_date and end_date
  dates <- as.Date(time(YourSpatraster))
  to_keep <- which(dates >= as.Date(start_date) & dates <= as.Date(end_date))
  YourSpatraster <- YourSpatraster[[to_keep]]
  # Function to detect leap years
  is_leap_year <- function(years) {
    return((years %% 4 == 0 & years %% 100 != 0) | (years %% 400 == 0))
  }
  dates <- as.Date(time(YourSpatraster))  # Dates
  years <- as.integer(format(dates, "%Y")) # Years
  # Build a dataframe with the layer number, the doy and the corrected doy (366, 60 don't exist in non leap year)
  df <- data.frame( date = dates,
                    N_layer = seq(1,terra::nlyr(YourSpatraster),1),
                    leap_year = is_leap_year((years)),
                    doy = as.integer(format(dates, "%j"))) #day of the year
  df$doy2 <- ifelse(df$doy >= 60 & !df$leap_year, df$doy+1, df$doy)
  # For each day of the year from 0 to 366, get a list of the layers to use to calculate baseline
  doy_indices <- vector("list", 366)
  for (j in 1:366) {
    days_in_window <- ((j - time_window):(j + time_window)) %% 366 ## %% 366 is a 'modulo' which mean that when a number reach 366 it is converted to 0 and the series that over from 0, 1, 2...
    days_in_window[days_in_window == 0] <- 366 # to avoid 0
    doy_indices[[j]]<- df$N_layer[which(df$doy2 %in% days_in_window)]
  }
  # Calculate baseline according the chosen methodology
  if (threshold == "qt"){
    # function to calculate percentile on a specific time_window
    q_rolling <- function(values, na.rm = TRUE) {
      terra::quantile(values, probs = quantile_value, na.rm = na.rm)
    }
  baseline_list <- lapply(1:366, function(i) {
      terra::app(YourSpatraster[[doy_indices[[i]]]], fun = q_rolling)
    })
  baseline <- terra::rast(baseline_list) #convert to Spatraster
  } else if (threshold == "mean"){        # if the baseline chosen is a mean value then enter loop bellow
    baseline_list <- lapply(1:366, function(i) {
      terra::app(YourSpatraster[[doy_indices[[i]]]], fun = mean)
    })
  baseline <- terra::rast(baseline_list) #convert to Spatraster
  }   
  # Smooth the value with an 11 days moving average
  smooth_indices <- vector("list", 366)
  for (s in 1:366) {
    days_in_window <- ((s - smooth_window):(s + smooth_window)) %% 366
    days_in_window[days_in_window == 0] <- 366  
    smooth_indices[[s]] <- days_in_window
  }
  baseline <- lapply(1:366, function(i) {
    terra::app(baseline[[smooth_indices[[i]]]], fun = mean, na.rm = TRUE)
    })
  baseline <- terra::rast(baseline)
  return(baseline)
}

```