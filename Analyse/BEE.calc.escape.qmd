---
title: "BEE.calc.escape"
author: "Victoria"
format: html
editor: visual
editor_options: 
  chunk_output_type: console
---

@description This function calculate the mediane distance, mean distance and standard deviation of distance to escape form an extreme event 'as the crow files' (but avoiding NA pixels) through time for a given GPS position or for all pixels.

@param data is Corrected_rasters, a binarized Spatraster (BEE.calc.true_event(binarized_EE, n = 5, d = 3)\[\["stacked_rasters_corrected"\]\]). (0 outside of event, 1 extreme event, NA land or missing data) OR Events_corrected, a list of df (obtained using BEE.calc.true_event(binarized_EE, n = 5, d = 3)\[\["Event_corrected"\]\] ) @param start_date and end_date defines the timeframe in during which you want to analyse distance to escape. If no dates are provided, computation will be done on all days_provided @param Set account_all_days = 'TRUE' if you want to perform calculations using all the days. Use account = 'FALSE' when you want to calculate only for the days when your reference point is experiencing an extreme event. By default, account_all_days is set on FALSE @param compute_by_event allows to specify if you want your result by extreme event or for the whole time periode specified. @param coords=NULL by defaults, values will be computed for all pixels of the raster, if your resolution is high and spatial exent is wide, this may be long. If you provide coordinate in decimal degrees (vector or df), values will only be computed for the given point.

@note all distance metrics are limited by the size of the Spatraster your are providing.

```{r}
# start_date = "2022-01-01"; end_date = "2024-12-31"; coords = GPS[1,c(1,2)] ; account_all=FALSE
BEE.calc.escape<- function(data, 
                           start_date = NULL, end_date = NULL, 
                           coords, 
                           account_all_days = FALSE, 
                           compute_by_event = FALSE){
  ##############################################################################
  ################### data <- Corrected_rasters ################################
  ##############################################################################
  if (class(data[1])=="SpatRaster"){
    #Check that compute_by_event = FALSE, Corrected_rasters is not the right data set to cumpute by event
    if (compute_by_event == TRUE){
      warning("The dataset you provided is not in the expected format to compute distance by extreme event. \n If you don't want to compute the distances metrics by extreme event, please withdraw your argument 'compute_by_event=TRUE' or set 'compute_by_event=FALSE")
    }
    #Subset the timeframe
    if (!is.null(start_date) | !is.null(end_date)){
      ## Check that date format matches
      format_start_date <- guess_formats(start_date, orders = c("dmy", "ymd", "mdy"))
      format_end_date <- guess_formats(end_date, orders = c("dmy", "ymd", "mdy"))
      format_layers_names <- guess_formats(names(data[[1]]), orders = c("dmy", "ymd", "mdy"))
      same_format <- all(format_start_date %in% format_layers_names)
      same_format <- c(same_format, all(format_end_date %in% format_layers_names))
      if(any(same_format==FALSE)){
        warning("The format of start_date or end_date does not match the format of the dates in Corrected_raster. Please run names(Corrected_raster[[1]]) to check the required format.")
        stop()
      }
      else{
        ## Retrive
        start_date <- ifelse(is.null(start_date), names(data[[1]]), start_date)
        end_date <- ifelse(is.null(end_date), names(data[[nlyr(data)]]), end_date)
        rasters <- data[[which(names(data) >= start_date & names(data) <= end_date)]]
      }
    }
    if (is.null(start_date) & is.null(end_date)){
      ## Adjust variable name to match the rest of the function
      rasters <- data 
    }
    
    ############################################################################
    ##################### coords <- GPS[1,c(1,2)] ##############################
    if(!is.null(coords)){
      ##################### account_all <- False ###############################
      if(account_all==FALSE){
        # subset the days for which your reference point is experiencing an EE
        pixel_of_interest <- terra::cellFromXY(rasters, coords)
        EE<-as.vector(terra::extract(rasters, pixel_of_interest))
        rasters <- rasters[[which(EE==1)]]
      }
      distances <- lapply(rasters, function(x){ # x <- rasters[[1]]
        # compute for each non NA pixel the shortest distance to a pixel of value 0, NA pixels are avoided
        r_dist <- terra::gridDist(x, target=0) #rasters unit is degrees -> results will be in meters
        return(r_dist)
      })
      message("This function use terra::gridDist. If your data are in degrees (lon/lat) or in meters, terra::gridDist output is in meters, for better lisibility, we converted it to kilometers. If you have any doupts, please check ?terra::gridDist()")
      distances <- rast(distances) # transform to Spatraster
      distances <- terra::extract(distances, pixel_of_interest)
      #convert to data.table
      distances <- data.table(dates = colnames(distances)[-1],
                              daily_shortest_dist = t(distances)[-1])
      dist <- data.table(Nb_days_pixel_1 = length(distances$dates),
                         Nb_days_no_escape = length( distances$daily_shortest_dist[ which( is.na(distances$daily_shortest_dist) ) ] ),
                         Mean_dist = mean(distances$daily_shortest_dist, na.rm=TRUE)/1000,
                         Sd_dist = sd(distances$daily_shortest_dist, na.rm=TRUE)/1000,
                         Median_dist = median(distances$daily_shortest_dist, na.rm=TRUE)/1000,
                         Min_dist = min(distances$daily_shortest_dist, na.rm=TRUE)/1000,
                         Max_dist = max(distances$daily_shortest_dist, na.rm=TRUE)/1000,
                         First_quart = quantile(x = distances$daily_shortest_dist, na.rm=TRUE)[2]/1000,
                         Thrid_quart =quantile(x = distances$daily_shortest_dist, na.rm=TRUE)[4]/1000)
      dist <- as.data.frame(dist)
      output <- list(distances_all_days=distances,dist_summary=dist)
      return(output)
    }
  }
}
```
