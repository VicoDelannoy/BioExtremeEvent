---
title: "BEE.calc.baseline"
author: "Victoria"
format: html
editor: visual
editor_options: 
  chunk_output_type: console
---

\#'@description *BEE.calc.baseline* : Creates a baseline from a SpatRaster by compiling cell data according to the chosen threshold

Only two threshold can be set :

-   "*qt*" : calculate the value of the 90th percentile for each cell at the time resolution of the dataset. For instance, it calculate the value of the threshold for each day of a theoretical year if the data has a daily resolution or for each month if data has a monthly resolution. To simplify analysis, the 29th of February is deleted if present.
-   "*mean*" : calculate the mean value for each cell at the time resolution of the data set .

# rast_name = ds ; start_date=NULL; end_date = "1987-12-31" ; threshold = "qt"; quantile_value = 0.9 ; time_window = 5

# time_window = 5 \<-\> 11 days centered on d day

BEE.calc.baseline \<- function(rast_name, start_date=NULL, end_date=NULL, threshold, quantile_value, time_window = 5){

\# Subset the dataset to the chosen strat_date and end-date if necessary if (!is.null(start_date) \| !is.null(end_date)){ if ( is.null(start_date) ){ start_date \<- names(rast_name)\[1\] warning("You have provided an 'end_date' but no 'start_date', first date of the dataset (",start_date,") have been used as first day of the baseline." ) } if ( is.null(end_date) ){ end_date \<- names(rast_name)\[nlyr(rast_name)\] warning("You have provided a 'start_date' but no 'end_date', last date of the dataset (", end_date,") have been used as last day of the baseline." ) } layer_dates \<- as.Date(names(ds)) selected_layers \<- which(layer_dates \>= start_date & layer_dates \<= end_date) rast_name \<- ds\[\[selected_layers\]\] }

ncor = detectCores()-2 \# count how many cores there are in the system and ask to use all of them except 2 cl =makeCluster(ncor) \# create a cluster to do calculation in parallel using ncor

if (threshold == "qt"){ \# check which threshold was asked by the operator if (is.null(quantile_value)) {return("Error : if you want to calculate the quantile at each point you need to precise which quantile in the argument : ex : quantile_value=90 for the 90th quantile. If you want to calculate the mean, use threshold='mean'.")} if (quantile_value \< 0 \| quantile_value \>1){ return("Error : 'quantile_value' argument must be between 0 and 1")}

```         
q =  function(x, na.rm = TRUE){   # define a function 'q' to estimate the value of the quantile value  for each pixel of the raster (x must be a raster), NA are delete before calculation
  return(quantile(x,quantile_value,na.rm=na.rm)) #quantile needs several arguments so it would be confusing to have this function directly in tapp + tapp is not directly compatible with complex function
}

baseline <- tapp(rast_name,index = "doy", fun = q, cores = cl) #tapp is a function from terra package that apply a function (here q) to the group of values from the same day of the year across all years available
stopCluster(cl)}                    # close core cluster
```

else if (threshold == "mean"){ \# if the baseline chosen is a mean value then enter loop bellow baseline \<- tapp(rast_name,index = "doy", fun = mean, cores = cl) #directly uses the mean option already existing in tapp function stopCluster(cl)} \# close core cluster return(baseline) }

## Version 2

BEE.calc.baseline <- function(rast_name, start_date=NULL, end_date=NULL, threshold, quantile_value, time_window = 5){
  
  # Subset the dataset to the chosen strat_date and end-date if necessary
  if (is.null(start_date) | !is.null(end_date)){
    if ( is.null(start_date) ){
      start_date <- names(rast_name)[1]
      warning("You have provided an 'end_date' but no 'start_date', first date of the dataset (",start_date,") have been used as first day of the baseline."  )
    }
    if ( is.null(end_date) ){
      end_date <- names(rast_name)[nlyr(rast_name)]
      warning("You have provided a 'start_date' but no 'end_date', last date of the dataset (", end_date,") have been used as last day of the baseline."  )
    }
  }
  ## cut rast_name to only keep the part between start_date and end_date
  dates <- as.Date(time(rast_name))
  to_keep <- which(dates >= as.Date(start_date) & dates <= as.Date(end_date))
  rast_name <- rast_name[[to_keep]]
  # terra::tapp can be apply to a specific subset of layers and the layers can be called by there index. Lets create a list of indexes :
  ## 1. Identify leap year in the dataset
  is_leap_year <- function(years) {
    return((years %% 4 == 0 & years %% 100 != 0) | (years %% 400 == 0))
  }
  ### 2. Get all the dates availbale in the Spatraster
  dates <- as.Date(time(rast_name))  # Dates
  years <- as.integer(format(dates, "%Y")) # Years
  doy <- as.integer(format(dates, "%j")) # Days of the year
  ### Check for leap year
  leap_years <- is_leap_year(years) #check for each day if it belongs to a leap year or not
  #doy_max <- ifelse(leap_years, 366, 365) # adapte the modulo (bellow) to fit the length of the each year
  # Indices vector (366 DOY possibles)
  doy_indices <- vector("list", 366)
  
  ## 3. Go trough each days of a 366 days year
  for (j in 1:366) {
    # Deal with the 29th of febuary (supposed to be the 60th day of the year when existing)
    if (j <60) {
      # Get all the DOY in the time_window (DOY - window_size à DOY + window_size)
      days_in_window <- ((j - time_window):(j + time_window)) %% 365 ## %% 366 is a 'modulo' which mean that when a number reach 366 it is converted to 0 and the series that over from 0, 1, 2...
      days_in_window[days_in_window == 0] <- 365  # Correction to avoid 0 value for the DOY
      selected_layers <- which(doy %in% days_in_window)
      doy_indices[[j]] <- selected_layers
    }
  }
        if (j == 60) {
          for (y in seq(1,length(unique(years)),1)){
            if (is_leap_year(unique(years))[y]){ # if it is not a leap_year, we run normal script but store it under doy 61 so the doy stay align between leap year (366) and non leap year (365)
              # Get all the DOY in the time_window (DOY - window_size à DOY + window_size)
        days_in_window <- ((j - time_window):(j + time_window)) %% 366 ## %% 366 is a 'modulo' which mean that when a number reach 366 it is converted to 0 and the series that over from 0, 1, 2...
        days_in_window[days_in_window == 0] <- 366  # Correction to avoid 0 value for the DOY
      
        # Generate the index for those days
        selected_layers <- which(doy %in% days_in_window)
        doy_indices[[j+1]] <- selected_layers
            }
            if (is_leap_year(unique(years))[y]){ #if it is a leap_year we run normal script but store it under doy 60
              days_in_window <- ((j - time_window):(j + time_window)) %% 366 ## %% 366 is a 'modulo' which mean that when a number reach 366 it is converted to 0 and the series that over from 0, 1, 2...
              days_in_window[days_in_window == 0] <- 366  # Correction to avoid 0 value for the DOY
      
        # Generate the index for those days
              selected_layers <- which(doy %in% days_in_window)
              doy_indices[[j+1]] <- selected_layers
          }
        }
        if (j != 60 & j > 60) {
        # Get all the DOY in the time_window (DOY - window_size à DOY + window_size)
        days_in_window <- ((j - time_window):(j + time_window)) %% 366 ## %% 366 is a 'modulo' which mean that when a number reach 366 it is converted to 0 and the series that over from 0, 1, 2...
        days_in_window[days_in_window == 0] <- 366  # Correction to avoid 0 value for the DOY
      
        # Generate the index for those days
        selected_layers <- which(doy %in% days_in_window)
        doy_indices[[j+1]] <- selected_layers
      }
            
            
      
      
  
  if (threshold == "qt"){
    # function to calculate percentile on a specific time_window
    q_rolling <- function(values, na.rm = TRUE) {
      quantile(values, probs = quantile_value, na.rm = na.rm, type=7)
    }
    baseline <- terra::tapp(rast_name, doy_index_list, fun = q_rolling)
  } else if (threshold == "mean"){        # if the baseline chosen is a mean value then enter loop bellow
    baseline <- terra::tapp(rast_name, index = doy_index_list, fun = mean, width = time_window) #directly uses the mean option already existing in tapp function
  }    
  
  return(baseline)
  }    




## Version 3
rast_name = ds ; start_date=NULL; end_date = "2010-12-31" ; threshold = "qt"; quantile_value = 0.9 ; time_window = 5 ; smooth_window=10
```{r}
BEE.calc.baseline <- function(rast_name, start_date=NULL, end_date=NULL, threshold, quantile_value=NULL, time_window=5, smooth_window=10){
  
  # Subset the dataset to the chosen strat_date and end-date if necessary
  if (is.null(start_date) | !is.null(end_date)){
    if ( is.null(start_date) ){
      start_date <- names(rast_name)[1]
      warning("You have provided an 'end_date' but no 'start_date', first date of the dataset (",start_date,") have been used as first day of the baseline."  )
    }
    if ( is.null(end_date) ){
      end_date <- names(rast_name)[nlyr(rast_name)]
      warning("You have provided a 'start_date' but no 'end_date', last date of the dataset (", end_date,") have been used as last day of the baseline."  )
    }
  }
  # Cut rast_name to only keep the part between start_date and end_date
  dates <- as.Date(time(rast_name))
  to_keep <- which(dates >= as.Date(start_date) & dates <= as.Date(end_date))
  rast_name <- rast_name[[to_keep]]
  # Function to detect leap years
  is_leap_year <- function(years) {
    return((years %% 4 == 0 & years %% 100 != 0) | (years %% 400 == 0))
  }
  dates <- as.Date(time(rast_name))  # Dates
  years <- as.integer(format(dates, "%Y")) # Years
  # Build a dataframe with the layer number, the doy and the corrected doy (366, 60 don't exist in non leap year)
  df <- data.frame( date = dates,
                    N_layer = seq(1,nlyr(rast_name),1),
                    leap_year = is_leap_year((years)),
                    doy = as.integer(format(dates, "%j"))) #day of the year
  df$doy2 <- ifelse(df$doy >= 60 & !df$leap_year, df$doy+1, df$doy)
  # For each day of the year from 0 to 366, get a list of the layers to use to calculate baseline
  doy_indices <- vector("list", 366)
  for (j in 1:366) {
    days_in_window <- ((j - time_window):(j + time_window)) %% 366 ## %% 366 is a 'modulo' which mean that when a number reach 366 it is converted to 0 and the series that over from 0, 1, 2...
    days_in_window[days_in_window == 0] <- 366 # to avoid 0
    doy_indices[[j]]<- df$N_layer[which(df$doy2 %in% days_in_window)]
  }
  # Calculate baseline according the chosen methodology
  if (threshold == "qt"){
    # function to calculate percentile on a specific time_window
    q_rolling <- function(values, na.rm = TRUE) {
      terra::quantile(values, probs = quantile_value, na.rm = na.rm)
    }
  baseline_list <- lapply(1:366, function(i) {
      terra::app(rast_name[[doy_indices[[i]]]], fun = q_rolling)
    })
  baseline <- rast(baseline_list) #convert to Spatraster
  } else if (threshold == "mean"){        # if the baseline chosen is a mean value then enter loop bellow
    baseline_list <- lapply(1:366, function(i) {
      terra::app(rast_name[[doy_indices[[i]]]], fun = mean)
    })
  baseline <- rast(baseline_list) #convert to Spatraster
  }   
  # Smooth the value with an 11 days moving average
  smooth_indices <- vector("list", 366)
  for (s in 1:366) {
    days_in_window <- ((s - smooth_window):(s + smooth_window)) %% 366
    days_in_window[days_in_window == 0] <- 366  
    smooth_indices[[s]] <- days_in_window
  }
  baseline <- lapply(1:366, function(i) {
    terra::app(baseline[[smooth_indices[[i]]]], fun = mean, na.rm = TRUE)
    })
  baseline <- rast(baseline)
  return(baseline)
}

```

